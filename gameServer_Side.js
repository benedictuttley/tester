/////////// Game Class -> Submitted by Developer ///////////

class Game {

    // Setting up instance variables that store game state...
    constructor(roomId, io) {
        this.roomId = roomId; // --> Stores the unique id for the lobby, 'lobby = room' in our case and is reference throughout when we want to send messages
                              //     from the server to every connection, 'user' of a particular room, such as updating the front end state for that room,
                              //     but critically not for other rooms.
        this.io = io;
        this.Users = []; // --> Stores the games user's state including their username and score.
        this.gUsers = []; // --> Stores the socket objects and their respective names, which is used when removing a user from the game, on disconnect.
        this.initialWidth = 50;
        this.currentWidth = this.initialWidth; // Progress display settings for user (visually represents how close they, or others are to winning).
        this.winWidth = 600;
        this.Gl_ans = 0; // Stores the answer to the current question displayed to users, whcih is used to 'mark' user answers.
    }

    showUsers() {
        console.log("Number of players in the lobby: " + this.gUsers.length);
        if (this.gUsers.length == 3) { // Sets the maximum number of users needed to start the game, this should really be dynamic instead of hardcoded (user choice?)
            this.startGame(); // When number of users required has been met, the game is started and game logic starts execution.z
        }
    }

    addUsertoGame(socketId, name) { // When a new user has connected to a particular lobby, we add thre socketId and associcated name for reference in
        // various methods.
        this.Users.push(socketId);
        this.Users.push(name);

    }

    InformUserOfLobby(socket) {
        socket.emit("test", this.roomId);
    }

    
    // Game state stored in the following instance variables...
    addUser(playerName) { // A new users state is strored in a user variable which is then added to the list of users.
        var user = {
            name: playerName,
            score: 0
        }
        this.gUsers.push(user);

        this.updateUsers();
    }

    // Method to remove a user from the list of users when they have disconnnected
    removeUser(user) {

        for (var i = 0; i < this.gUsers.length; i++) {
            // Iterate through list of users until correct user is identified...
            if (user == this.gUsers[i].name) {
                // Removing user entry from list of users...
                this.gUsers.splice(i, 1);
                console.log("User: " + user + " has left the game");
                this.updateUsers();


                console.log("");
                console.log("PLAYER " + user + " HAS LEFT THE GAME...");
                console.log("");
            };
        };

        if (this.gUsers.length == 1) {
            this.endGame();
        }
    }


    /*Method to update the array of users, this method is executed when an existing user leaves or when a new user joins. Then we send a emit
     to all the currently connected users with the updated array of users. This method is useful as it means that we can essentially display the current
     up to date list of users in the game so that a player knows the username and score of the players they are against.*/
    updateUsers() {

        // Broadcast all the user names of the users that are in the game to all of the users...
        console.log("Users present in the game: " + this.gUsers.length);
        this.io.sockets.in(this.roomId).emit("users", this.gUsers);
    };

    // This will cause the client loading screen to be hidden and the first question of the game generated by the updateQuestion() method
    startGame() {
        this.io.sockets.in(this.roomId).emit("gameStarted", true);
        this.updateQuestion();
    }


    /*This method is triggered in the case when there is only one user left in the game and so they win by default.
    IMPORTANT: This method will need to redirect the user back to the game page when the game ends so that they are not just stuck on the game
    page. In addition when the game is over the game instance needs it summary data written to the SQL database and it will then need to be removed
    from the myGameInstances array.*/
    endGame() {

        console.log("endGame() is called");
        var destination = '/home.html';
        this.io.sockets.in(this.roomId).emit("gameEnded",destination);
    }


    // This method is called when a user has submitted an answer and checks if it is correct. If the submitted answer is correct then an emit is
    // sent that will result in the client updating the view of the divs as to be longer for the one representing the user that has indeed answered
    // the question correctly.
    evalAnswer(data) {

        // need to get player info from gUsers...
        if (data.answer == this.Gl_ans) {
            console.log("correct answer supplied");
            for (var i = 0; i < this.gUsers.length; i++) {
                if (this.gUsers[i].name == data.player) {
                    this.gUsers[i].score += 1; // Increment the score for that player

                }

                // First user to answer 10 questions correctly wins the game
                if (this.gUsers[i].score == 10) {
                    this.io.sockets.emit("gameWon", {
                        message: "<strong>" + this.gUsers[i].name + "</strong> won the game!"
                    });
                    this.endGame();
                };
            }

            this.io.sockets.in(this.roomId).emit("corr_ans", {
                message: "<strong>" + data.player + "</strong> got it correct!"
            });
            this.updateQuestion(); // Now that a user has correctly answered the question we need to generate and transmit a new question, this is
                                   // done through the updateQuestion method.

        }
    }

    // This method generates a new question aswell as calculating the answer in advance so that it can be evaluated against submitted answers.
    updateQuestion() {
        console.log("");
        var a = Math.floor(Math.random() * 10) + 1;
        var b = Math.floor(Math.random() * 10) + 1;
        var op = ["*", "+", "/", "-"]; // One of four operators will be randomly chosen for the new question.
        // Choose an operator from the above list at random...
        var opChoice = [Math.floor(Math.random() * 4)]
        var answer = eval(a + op[opChoice] + b);
        console.log("How much is " + a + " " + op[opChoice] + " " + b + "?");
        // Logging the answer to the current question for tetsing purposes...
        console.log("Answer to current question is: " + answer);
        this.Gl_ans = answer;
        // Broadcast the new question to all connected users...
        this.io.sockets.in(this.roomId).emit("newQuestion", "How much is " + a + " " + op[opChoice] + " " + b + "?");
        console.log("Question for lobby: " + this.roomId + "How much is " + a + " " + op[opChoice] + " " + b + "?");
        this.io.sockets.in(this.roomId).emit('test', this.roomId);
        this.updateUsers();
    }
}

/////////// Game Class -> Submitted by Developer ///////////

// export the unique game class for use in index.js
module.exports = Game;


